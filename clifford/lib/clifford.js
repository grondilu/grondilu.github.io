/*
 * Copyright (c) 2018 Lucien Grondin <grondilu@yahoo.fr>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
"use strict";
const log2 = Math.log(2);

class Rat {
  constructor(num, den = 1) {

    let numerator = BigInt(num),
      denominator = BigInt(den),
      gcd = (
        function BigIntGCD(a, b) { return BigInt(b ? BigIntGCD(b, a % b) : (a > 0 ? a : -a)); }
    )(numerator, denominator);
    this.numerator = numerator/gcd;
    this.denominator = denominator/gcd;
  }
  add(that) { return new Rat(this.numerator*that.denominator + that.numerator*this.denominator, this.denominator*that.denominator); }
  subtract(that) { return this.add(that.opposite); }
  multiply(that) { return new Rat(this.numerator*that.numerator, this.denominator*that.denominator); }
  divide(that) { return new Rat(this.numerator*that.denominator, this.denominator*that.numerator); }
  toString() { return this.denominator == 1 ? this.numerator.toString() : this.numerator+"/"+this.denominator; }
  toTeX() { return this.denominator == 1 ? this.numerator.toString() : '\\frac{' + this.numerator + '}{' + this.denominator + '}'; }
  isOne() { return this.numerator === this.denominator; }
  isZero() { return this.numerator == 0; }
  get opposite() { return new Rat(-this.numerator, this.denominator); }
  static get zero() { return new Rat(0); }
  static get one() { return new Rat(1); }
}
function permutationSign(...p) {
  // permutation sign for a list of integers
  let n = p.length, sgn = 1;
  for(let i=0; i<n; ++i)
    for(let j=0; j<i; ++j) {
      if(p[i] < p[j]) sgn *= -1
      else if(p[i] === p[j]) return 0
    }
  return sgn
}
function grade(b) {
  let n = 0;
  while (b > 0) {
    if (b&1n) n++;
    b >>= 1n;
  }
  return n;
}
function sign(a, b) {
  // sign of the product of two bit-Encoded blades
  let n = a >> 1n, sum = 0;
  while (n > 0) {
    sum += grade(n & b);
    n >>= 1n;
  }
  return sum & 1 ? -1 : 1;
}

const parser = /*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function() {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = " ",
        peg$c1 = peg$literalExpectation(" ", false),
        peg$c2 = function(head, tail) {
                  return tail.reduce(
                      (left, element) => ({ type: element[1], args: [left, element[3]]}),
                      head
                  );
              },
        peg$c3 = function(head, tail) {
                  return tail.reduce(
                      (left, element) => ({ type: element[1], args: [left, element[3]]}),
                      head
                  );
            },
        peg$c4 = "+",
        peg$c5 = peg$literalExpectation("+", false),
        peg$c6 = function() { return "addition"; },
        peg$c7 = "-",
        peg$c8 = peg$literalExpectation("-", false),
        peg$c9 = function() { return "subtraction"; },
        peg$c10 = "/",
        peg$c11 = peg$literalExpectation("/", false),
        peg$c12 = function() { return "division"; },
        peg$c13 = "*",
        peg$c14 = peg$literalExpectation("*", false),
        peg$c15 = function() { return "multiplication"; },
        peg$c16 = "\xB7",
        peg$c17 = peg$literalExpectation("\xB7", false),
        peg$c18 = function(left, right) {
                return {
                    type: "·",
                    args: [ left, right ]
                }
            },
        peg$c19 = "\u2227",
        peg$c20 = peg$literalExpectation("\u2227", false),
        peg$c21 = function(left, right) {
                return {
                    type: "∧",
                    args: [ left, right ]
                }
            },
        peg$c22 = function(type, argument) {
                return { type, args: [ argument ] }
            },
        peg$c23 = "**",
        peg$c24 = peg$literalExpectation("**", false),
        peg$c25 = function(left, right) {
                return { type: "exponentiation", args: [ left, parseInt(right) ] }
            },
        peg$c26 = "\xB2",
        peg$c27 = peg$literalExpectation("\xB2", false),
        peg$c28 = function(left) {
              return { type: "exponentiation", args: [ left, 2 ] }
            },
        peg$c29 = "(",
        peg$c30 = peg$literalExpectation("(", false),
        peg$c31 = ")",
        peg$c32 = peg$literalExpectation(")", false),
        peg$c33 = function(additive) { return additive; },
        peg$c34 = function() { return { type: "number", args: [ text() ] } },
        peg$c35 = ".",
        peg$c36 = peg$literalExpectation(".", false),
        peg$c37 = "0",
        peg$c38 = peg$literalExpectation("0", false),
        peg$c39 = /^[0-9]/,
        peg$c40 = peg$classExpectation([["0", "9"]], false, false),
        peg$c41 = /^[1-9]/,
        peg$c42 = peg$classExpectation([["1", "9"]], false, false),
        peg$c43 = /^[a-z]/,
        peg$c44 = peg$classExpectation([["a", "z"]], false, false),
        peg$c45 = function() { return { type: "variable", args: text() } },
        peg$c46 = "$",
        peg$c47 = peg$literalExpectation("$", false),
        peg$c48 = function(index) {
            return { type: "basis vector", args: [ +1, index ] }
        },
        peg$c49 = "#",
        peg$c50 = peg$literalExpectation("#", false),
        peg$c51 = function(index) {
            return { type: "basis vector", args: [ -1, index ] }
        },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parseAdditiveExpression();

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c0;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
      }

      return s0;
    }

    function peg$parseAdditiveExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseMultiplicativeExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseAdditiveOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseMultiplicativeExpression();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseAdditiveOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseMultiplicativeExpression();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMultiplicativeExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parsecdot();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMultiplicativeOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecdot();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseMultiplicativeOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecdot();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c3(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAdditiveOperator() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c4;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c9();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseMultiplicativeOperator() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s1 = peg$c10;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c12();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 42) {
          s1 = peg$c13;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c15();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseUnaryOperator() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 43) {
        s0 = peg$c4;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s0 = peg$c7;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
      }

      return s0;
    }

    function peg$parsecdot() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsewedge();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 183) {
          s2 = peg$c16;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c17); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsewedge();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c18(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsewedge();
      }

      return s0;
    }

    function peg$parsewedge() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseUnaryExpression();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 8743) {
          s2 = peg$c19;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c20); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsewedge();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c21(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseUnaryExpression();
      }

      return s0;
    }

    function peg$parseUnaryExpression() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseUnaryOperator();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseUnaryExpression();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c22(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseexponential();
      }

      return s0;
    }

    function peg$parseexponential() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseprimary();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c23) {
          s2 = peg$c23;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c24); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDecimalIntegerLiteral();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseprimary();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 178) {
            s2 = peg$c26;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c27); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c28(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseprimary();
        }
      }

      return s0;
    }

    function peg$parseprimary() {
      var s0, s1, s2, s3;

      s0 = peg$parseLiteralNumber();
      if (s0 === peg$FAILED) {
        s0 = peg$parseVariable();
        if (s0 === peg$FAILED) {
          s0 = peg$parseBasisVector();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c29;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c30); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseAdditiveExpression();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s3 = peg$c31;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c32); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c33(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseLiteralNumber() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsesign();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDecimalIntegerLiteral();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedecimal_point() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 46) {
        s0 = peg$c35;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }

      return s0;
    }

    function peg$parseDecimalIntegerLiteral() {
      var s0, s1, s2, s3;

      if (input.charCodeAt(peg$currPos) === 48) {
        s0 = peg$c37;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNonZeroDigit();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDecimalDigit();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDecimalDigit();
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsesign() {
      var s0;

      s0 = peg$parseminus();
      if (s0 === peg$FAILED) {
        s0 = peg$parseplus();
      }

      return s0;
    }

    function peg$parseminus() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 45) {
        s0 = peg$c7;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }

      return s0;
    }

    function peg$parseplus() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 43) {
        s0 = peg$c4;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }

      return s0;
    }

    function peg$parsezero() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 48) {
        s0 = peg$c37;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }

      return s0;
    }

    function peg$parseDecimalDigit() {
      var s0;

      if (peg$c39.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }

      return s0;
    }

    function peg$parseNonZeroDigit() {
      var s0;

      if (peg$c41.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }

      return s0;
    }

    function peg$parseVariable() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c43.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c45();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseBasisVector() {
      var s0;

      s0 = peg$parseEuclideanBasisVector();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAntiEuclideanBasisVector();
      }

      return s0;
    }

    function peg$parseEuclideanBasisVector() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c46;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDecimalIntegerLiteral();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAntiEuclideanBasisVector() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c49;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDecimalIntegerLiteral();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c51(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})();

class BasisVector {
  constructor (index, square = 1) {
    // Checking parameter types
    if (index === undefined) throw new Error("undefined index");
    else if (!Number.isInteger(index)) throw new Error("index must be an integer");
    else if (index < 0) throw new Error("negative index");
    else if (square*square !== 1) throw new Error("non-unitary square");
    else {
      this.square = square;
      this.index  = index;
    }
  }
  bitEncoding()     { throw new Error("Virtual call"); }
  toString() { return this.letter + this.index; }
  toTeX() { return "\\mathbf{" + this.letter + "}_" + this.index; }
  get letter() { return this.square === 1 ? 'e' : 'ē'; }
  get order() { throw "virtual method call"; }
  static fromOrder(order) {
    return order >= 2 ?
      new AntiEuclideanBasisVector(order - 2) :
      new EuclideanBasisVector(Math.floor(1/(1 - order) - 2));
  }
}
class EuclideanBasisVector extends BasisVector {
  constructor (index) { super(index, 1); }
  get bitEncoding() { return 1n << BigInt(2*this.index); }
  get order() { return 1 - 1/(2 + this.index) }
}
class AntiEuclideanBasisVector extends BasisVector {
  constructor (index) { super(index, -1); }
  get bitEncoding() { return 1n << BigInt(2*this.index + 1); }
  get order() { return 2 + this.index; }
}


class Blade {
  // has basisVectors;
  // has Polynomial scale;
  static get zero() { return new Blade([], Polynomial.zero); }
  static get one() { return new Blade([], Polynomial.one); }
  constructor(...args) {
    if (args.every(x => x instanceof BasisVector)) {
      this.basisVectors = args;
      this.scale = new Polynomial(new Rat(permutationSign(...this.basisVectors.map(x => x.order))));
    }
    else if (args.length == 0) { this.basisVectors = []; this.scale = Polynomial.one; }
    else if (args.length == 1) {
      let arg = args[0];
      if (arg instanceof Polynomial) {
        this.basisVectors = []; this.scale = arg;
      } else if (arg instanceof Array) {
        if (arg.every(x => x instanceof BasisVector)) {
          this.basisVectors = args;
          this.scale = new Polynomial(new Rat(permutationSign(...this.basisVectors)));
        } else throw new Error("an array of basis vectors was expected");
      } else throw new Error("unsupported constructor argument of type " + arg.constructor.name);
    }
    else if (args.length == 2) {
      let arg0 = args[0], arg1 = args[1];
      if (arg0 instanceof Array && arg1 instanceof Polynomial) {
        this.basisVectors = arg0;
        this.scale = arg1;
      } else throw new Error("invalid two-arguments");
    } else throw new Error("could not parse arguments");
  }
  toString() {
    return this.basisVectors.length === 0 ? '1' :
      this.basisVectors
    .sort((a,b) => a.order - b.order)
    .map(x => x.toString())
    .join('∧');
  }
  toTeX() {
    if (this.basisVectors.length == 0) { return this.scale.toTeX(); }
    else {
      let scale = this.scale.toTeX();
      return (
        this.scale.degree > 0 ? `(${scale})` :
          this.scale.isOne() ? '' :
          this.scale.negate().isOne() ? '-' :
          scale
      ) +
      this.basisVectors.
        sort((a,b) => a.order - b.order).
        map(x => x.toTeX()).
        join('\\wedge ');
    }
  }
  wedge(that) {
    if (that instanceof Blade) {
      if (this.bitEncoding & that.bitEncoding) return Blade.zero;
      else return this.multiply(that);
    } else throw new Error("unsupported argument type");
  }
  multiply(that) {
    if (that instanceof Blade) {
      let basisVectors = [],
        scale = this.scale.multiply(that.scale),
        $sign = sign(this.bitEncoding, that.bitEncoding);
      for (
        let n = 1, bitEncoding = this.bitEncoding & that.bitEncoding;
        bitEncoding > 0;
        n *= -1, bitEncoding >>= 1n
      ) { if (bitEncoding & 1n) $sign *= n; }
      for (
        let n = 0, bitEncoding = this.bitEncoding ^ that.bitEncoding;
        bitEncoding > 0;
        n++, bitEncoding >>= 1n
      ) {
        if (bitEncoding & 1n) 
          basisVectors.push(
            new (n % 2 ? AntiEuclideanBasisVector : EuclideanBasisVector)(
              parseInt(n % 2 ? (n-1)/2 : n/2)
            )
          );
      }
      return new Blade(basisVectors, scale.multiply(new Polynomial(new Rat($sign))));
    } else throw new Error("unsupported argument type");
  }
  divide(that) {
    if (that instanceof Rat) {
      return new Blade(this.basisVectors, this.scale.divide(that));
    } else throw new Error("only Rat division supported");
  }
  negate() { return new Blade(this.basisVectors, this.scale.negate()); }
  get grade() { return this.basisVectors.length; }
  isZero() { return this.scale.isZero(); }
  get bitEncoding() {
    return this.basisVectors.
      map(x => x.bitEncoding).
      reduce((a,b) => a|b, 0n);
  }
}

class PoweredVariable {
  constructor(varname, power = 1) {
    if (!/^\w$/.test(varname))
      throw new Error("incorrect variable name " + variable);
    if (power < 1 || Math.floor(power) !== power)
      throw new Error("incorrect exponent " + power);
    this.varname = varname;
    this.power = power;
  }
  toString() { return this.varname + (this.power === 1 ? '' : '^'+this.power); }
  toTeX() { return this.toString(); }
  eval(dict) {
    if (this.varname in dict) {
      return Math.pow(dict[this.varname], this.power);
    } else throw "unknown variable " + this.varname;
  }
}

class Monomial {
  constructor(...poweredVars) {
    if (!poweredVars.every(x => x instanceof PoweredVariable))
      throw new Error("constructor accepts only powers of variables");
    if (new Set(poweredVars.map(x => x.varname)).size !== poweredVars.length)
      throw new Error("duplicated variable");
    this.poweredVars = poweredVars;
  }
  toString() {
    return this.poweredVars.
      sort((a, b) => a.varname < b.varname).
      map(x => x.toString()).
      join('*');
  }
  toTeX() {
    return this.poweredVars.
      sort((a, b) => a.varname < b.varname).
      map(x => x.toTeX()).
      join('');
  }
  eval(dict) {
    return this.poweredVars.
      map(x => x.eval(dict)).
      reduce((a, b) => a*b, 1)
  }
  get degree() {
    return this.poweredVars.
      map(x => x.power).
      reduce((a,b)=>a+b, 0);
  }
  multiply(that) {
    if (!(that instanceof Monomial))
      throw new Error("multiplicand is not a Monomial");
    let bag = {};
    for (let v of [...this.poweredVars, ...that.poweredVars]) {
      if (v.varname in bag) 
        bag[v.varname] += v.power;
      else bag[v.varname] = v.power;
    }
    return new Monomial(
      ...Object.keys(bag).map(name => new PoweredVariable(name, bag[name]))
    );
  }
}
class ScaledMonomial {
  constructor(monomial, scale = new Rat(1)) {
    if (!(monomial instanceof Monomial))
      throw new Error("first argument must be a monomial");
    if (!(scale instanceof Rat))
      throw new Error("scale must be an instance of Rat");
    this.scale = scale;
    this.monomial = monomial;
  }
  toString() {
    return (this.scale === +1 ? ''  :
            this.scale === -1 ? '-' :
            this.scale + '*') + this.monomial.toString();
  }
  toTeX() {
    if (this.degree == 0) return this.scale.toTeX();
    return (this.scale.isOne() ? '' :
       this.scale.opposite.isOne() ? '-' : this.scale.toTeX()
      ) + this.monomial.toTeX();
  }
  get degree() { return this.monomial.degree; }
  eval(dict = {}) { return new Rat(this.scale * this.monomial.eval(dict)); }
  multiply(that) {
    if (!(that instanceof ScaledMonomial))
      throw new Error("multiplicand is not a second class monomial");
    return new ScaledMonomial(
      this.monomial.multiply(that.monomial),
      this.scale.multiply(that.scale)
    );
  }
  negate() { return new ScaledMonomial(this.monomial, this.scale.opposite); }
  isZero() { return this.scale.isZero(); }
  isOne() { return this.scale.isOne(); }
}
class Polynomial {
  static get zero() { return new Polynomial(Rat.zero); }
  static get one() { return new Polynomial(Rat.one); }
  constructor(...args) {
    if (args.length === 1) {
      let arg = args[0];
      if (typeof(arg) == 'bigint') { return new Polynomial(new Rat(arg)); }
      else if (arg instanceof Rat) {
        this.monomials = [
          new ScaledMonomial(new Monomial(), arg)
        ];
      } else if (arg instanceof Monomial) {
        this.monomials = [ new ScaledMonomial(arg) ];
      } else if (arg instanceof ScaledMonomial) {
        this.monomials = [ arg ];
      } else throw new Error("unexpected argument type");
    } else if (args.every(x => x instanceof ScaledMonomial)) {
      if (
        new Set(
          args.map(x => x.monomial.toString())
        ).size !== args.length
      ) throw new Error("duplicated monomial");
      this.monomials = args;
    } else throw new Error("constructor only accepts second class monomial arguments");
  }
  eval(dict = {}) {
    return this.monomials.map(x => x.eval(dict)).reduce(
      (a,b) => a+b, 0
    );
  }
  subtract(that) { return this.add(that.negate); }
  add(that) {
    let scales = {}
    for (let scaledMonomial of this.monomials.concat(that.monomials)) {
      let monomial = scaledMonomial.monomial,
        scale = scaledMonomial.scale,
        key = monomial.toString();
      if (scales[key] === undefined) {
        scales[key] = { monomial, scale };
      } else {
        scales[key].scale = scales[key].scale.add(scale);
      }
    }
    let scaledMonomials = Object.values(scales).
        filter(x => !x.scale.isZero()).
      map(o => new ScaledMonomial(o.monomial, o.scale));
    if (scaledMonomials.length == 0) return Polynomial.zero;
    else return new Polynomial(...scaledMonomials);
  }
  multiply(that) {
    if (that instanceof Polynomial) {
      return [...(function* (monomials) {
        for (let i of monomials) for (let j of that.monomials)
          yield new Polynomial(i.multiply(j))
      })(this.monomials)].reduce((a,b) => a.add(b), Polynomial.zero);
    } else throw new Error("multiplicand is not a polynomial");
  }
  negate() { return new Polynomial(...this.monomials.map(m => m.negate())) ; }
  divide(that) {
    if (that instanceof Polynomial) {
      if (that.degree > 0) throw new Error("rational fractions NYI");
      return this.divide(that.monomials[0].scale);
    } else if (that instanceof Rat) {
      return new Polynomial(
        ...this.monomials.map(m => new ScaledMonomial(m.monomial, m.scale.divide(that)))
      );
    }
  }
  get degree() { return Math.max(...this.monomials.map(x => x.degree)); }
  toTeX() {
    return this.monomials.
    map(m => m.toTeX()).
    join('+').
    replace(/\+-/g, '-');
  }
  isZero() { return this.degree == 0 && this.monomials[0].isZero(); }
  isOne () { return this.degree == 0 && this.monomials[0].isOne(); }
}

class MultiVector {
  static get zero() { return new MultiVector(Blade.zero); }
  static get one() { return new MultiVector(Blade.one); }
  static fromParseTree(object) {
    if(typeof(object) !== "object") throw new Error("unexpected argument type");
    switch(object.type) {
      case "number":
        return new MultiVector(
          new Blade(new Polynomial(new Rat(object.args[0])))
      );
      case "basis vector":
        return new MultiVector(
          new Blade(
            new (object.args[0] == 1 ? EuclideanBasisVector : AntiEuclideanBasisVector)(
              parseInt(object.args[1])
            )
          )
      );
      case "addition":
        return object.args.map(MultiVector.fromParseTree).reduce((a,b) => a.add(b));
      case "subtraction":
        return object.args.map(MultiVector.fromParseTree).reduce((a,b) => a.subtract(b));
      case "multiplication":
        return object.args.map(MultiVector.fromParseTree).reduce((a,b) => a.multiply(b));
      case "division":
        return object.args.map(MultiVector.fromParseTree).reduce((a,b) => a.divide(b));
      case "variable":
        return new MultiVector(
          new Blade(
            new Polynomial(
              new ScaledMonomial(
                new Monomial(
                  new PoweredVariable(object.args[0])
                )
              )
            )
          )
      );
      case "exponentiation":
        return (function exponentiate(b, n) {
        return n == 0 ? MultiVector.fromParseTree({ type: "number", args: [ 1 ]}) :
          n == 1 ? b :
          (x => n % 2 == 0 ? x : x.multiply(b))(
            (x => x.multiply(x))(exponentiate(b, Math.floor(n/2)))
        );
      })(MultiVector.fromParseTree(object.args[0]), object.args[1]);
      default:
        throw new Error(object.type + " NYI");
    }
  }
  constructor(...args) {
    if (args.every(x => x instanceof Blade)) {
      if (new Set(args.map(x => x.toString())).size !== args.length)
        throw new Error("duplicated blade");
      this.blades = args;
    } else if (args.length === 1) {
      let arg = args[0];
      if (arg instanceof Blade || arg instanceof Polynomial) {
        this.blades = [ new Blade(arg) ];
      } else if (typeof(arg) == 'string') {
        let mv = MultiVector.fromParseTree(parser.parse(arg));
        this.blades = mv.blades;
      } else throw new Error("unexpected constructor argument of type " + args.constructor.name);
    } else throw new Error("unexpected constructor arguments of type " + args.constructor.name);
  }
  toTeX() { return this.blades.map(x => x.toTeX()).join("+"); }
  get grade() { return Math.max(...this.blades.map(x => x.grade)); }
  add(that) {
    if (that instanceof MultiVector) {
      let blades = {};
      for (let blade of this.blades.concat(that.blades)) {
        let key = blade.toString();
        if (blades[key] === undefined) {
          blades[key] = new Blade(blade.basisVectors, blade.scale);
        } else {
          blades[key].scale = blades[key].scale.add(blade.scale);
        }
      }
      blades = Object.values(blades).filter(x => !x.scale.isZero());
      if (blades.length == 0) return MultiVector.zero;
      else return new MultiVector(...blades);
    } else throw new Error("unexpected argument of type " + that.constructor.name);
  }
  multiply(that) {
    if (that instanceof MultiVector) {
      return [...(function* (blades) { for (let i of blades) for (let j of that.blades) {
        yield new MultiVector(i.multiply(j));
      }
      })(this.blades)].reduce((a,b) => a.add(b), MultiVector.zero)
    } else throw new Error("unsupported argument type");
  }
  divide(that) {
    if (that instanceof MultiVector) {
      if (that.grade == 0) {
        let polynomial = that.blades[0].scale;
        if (polynomial.degree == 0) {
          let rat = polynomial.monomials[0].scale;
          return new MultiVector(
            ...this.blades.map(b => b.divide(rat))
          );
        } else throw new Error("can't divide by true Polynomial");
      } else throw new Error("can't divide by true MultiVector");
    }
  }
  negate() { return new MultiVector(...this.blades.map(m => m.negate())); }
  subtract(that) { return this.add(that.negate()); }
}

